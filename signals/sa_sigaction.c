/*
 * POSIX.1b extension (aka POSIX.4) defines real time signals. With that some
 * other information is provided to the signalled process. Among them is a PID
 * of the process that sent a signal and UID. Example:
 *
 * $ ./a.out 		# and now kill 4114 with SIGTERM (just "kill 4114")
 * PID 4114 started...
 * sig received: TERM
 * signalled by PID: 3764
 * and process was owned by: janp
 *
 * Note: runs on Solaris
 *
 * (c) jp@devnull.cz, vlada@devnull.cz
 */

#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <strings.h>
#include <stdio.h>
#include <pwd.h>
#include <siginfo.h>

#define	MESSAGE "TERM signal caught !\n"

/* NOTE: this is not a safe signal handler ! */
void
term_handler(int sig, siginfo_t *info, void *ignored)
{
	char signame[SIG2STR_MAX];

	/* Ctrl-C on Solaris makes info to be NULL pointer. */
	if (info == NULL) {
		printf("NULL info, returning\n");
		return;
	}

	/*
	 * Was a signal generated by a user process? See a man page for
	 * siginfo.h(3HEAD) on Solaris for more information, or the spec.
	 *
	 * Note that SIGTERM should never be received otherwise than from a user
	 * process, that's what the signal is for. If curious, see what exactly
	 * si_code is for and what it can carry. Also, you may want to read more
	 * about sigqueue(3C) with its 2nd parameter.
	 */
	if (info->si_code != SI_NOINFO) {
		sig2str(info->si_signo, signame);
		printf("sig received: %s\n", signame);
		printf("signalled by PID: %d\n", info->si_pid);
		printf("and process was owned by: %s\n",
		    (getpwuid(info->si_uid))->pw_name);
		fflush(stdout);
	} else {
		printf("signal not generated from a user process.\n");
		printf("that means we got just a signal number.\n");
		sig2str(info->si_signo, signame);
		printf("sig received: %s\n", signame);
		fflush(stdout);
	}
}

int
main(void)
{
	struct sigaction act;

#ifndef _POSIX_REALTIME_SIGNALS
	errx(1, "sorry, POSIX.4 real time signals extensions "
	    "missing.");
#endif

	printf("PID %d started...\n", getpid());

	bzero(&act, sizeof (act));
	act.sa_sigaction = term_handler;
	/* must use this in order to use sa_sigaction field */
	act.sa_flags = SA_SIGINFO;
	/*
	 * You can change to SIGINT, and if you ^C it from the terminal, you
	 * will get no PID. That's because SIGINT is generated from the pseudo
	 * terminal driver (ie, kernel).
	 */
	(void) sigaction(SIGINT, &act, NULL);

	/* wait for a signal, anything else than SIGTERM will terminate us */
	while (1) {
		pause();
	}

	return (0);
}

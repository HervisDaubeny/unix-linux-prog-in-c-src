/*
 * POSIX.1b extension (aka POSIX.4) defines real time signals. With that some
 * other information is provided to the signalled process. Among them is a PID
 * of the process that sent a signal and UID. Example:
 *
 * $ ./a.out 		# and now kill 4114 with SIGINT ("kill -INT 4114")
 * PID 4114 started...
 * sig received: TERM
 * signalled by PID: 3764
 * and process was owned by: janp
 *
 * (c) jp@devnull.cz, vlada@devnull.cz
 */

#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <unistd.h>
#include <pwd.h>

#ifndef _POSIX_REALTIME_SIGNALS
#error	"sorry, POSIX.4 real time signals extensions missing."
#endif

/*
 * NOTE: this is not a safe signal handler since it is using unsafe functions
 * 	 like printf/fflush.
 */
void
sig_handler(int sig, siginfo_t *info, void *ignored)
{
	/* Ctrl-C on Solaris makes info to be NULL pointer. */
	if (info == NULL) {
		printf("NULL signal info, we only know the signal number\n");
		printf("sig received: %s\n", strsignal(sig));
		return;
	}

	/*
	 * Was a signal generated by a user process? See a man page for
	 * siginfo.h(3HEAD) on Solaris for more information, or the spec.
	 *
	 * Note that SIGTERM should never be received otherwise than from a user
	 * process, that's what the signal is for. If curious, see what exactly
	 * si_code is for and what it can carry. Also, you may want to read more
	 * about sigqueue(3C) with its 2nd parameter.
	 */
	if (info->si_code == SI_USER) {
		printf("sig received: %s\n", strsignal(info->si_signo));
		printf("signalled by PID: %d\n", info->si_pid);
		printf("and process was owned by: %s\n",
		    (getpwuid(info->si_uid))->pw_name);
	} else {
		printf("signal not generated from a user process.\n");
		printf("that means we got just a signal number.\n");
	}

	fflush(stdout);
}

int
main(void)
{
	struct sigaction act;

	printf("PID %d started...\n", getpid());

	bzero(&act, sizeof (act));
	act.sa_sigaction = sig_handler;
	/* must use this in order to use sa_sigaction field */
	act.sa_flags = SA_SIGINFO;
	/*
	 * If you ^C it from the terminal, you will get no PID. That's because
	 * SIGINT is generated from the pseudo terminal driver (ie, kernel).
	 */
	(void) sigaction(SIGINT, &act, NULL);

	/* wait for a signal, anything else than SIGTERM will terminate us */
	while (1) {
		pause();
	}

	return (0);
}
